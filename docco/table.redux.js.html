<!DOCTYPE html>

<html>
<head>
  <title>table.redux.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>

      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">


                <a class="source" href="actor.js.html">
                  actor.js
                </a>


                <a class="source" href="addresser.js.html">
                  addresser.js
                </a>


                <a class="source" href="connector.js.html">
                  connector.js
                </a>


                <a class="source" href="consensus.js.html">
                  consensus.js
                </a>


                <a class="source" href="countdown.js.html">
                  countdown.js
                </a>


                <a class="source" href="diffuser.js.html">
                  diffuser.js
                </a>


                <a class="source" href="dispatcher.js.html">
                  dispatcher.js
                </a>


                <a class="source" href="hangup.js.html">
                  hangup.js
                </a>


                <a class="source" href="hash.js.html">
                  hash.js
                </a>


                <a class="source" href="initializer.js.html">
                  initializer.js
                </a>


                <a class="source" href="lookup.js.html">
                  lookup.js
                </a>


                <a class="source" href="middleware.js.html">
                  middleware.js
                </a>


                <a class="source" href="notes.js.html">
                  notes.js
                </a>


                <a class="source" href="olio.js.html">
                  olio.js
                </a>


                <a class="source" href="registrar.js.html">
                  registrar.js
                </a>


                <a class="source" href="requester.js.html">
                  requester.js
                </a>


                <a class="source" href="table.js.html">
                  table.js
                </a>


                <a class="source" href="table.redux.js.html">
                  table.redux.js
                </a>

            </div>
          </div>
        </li>
      </ul>

    <ul class="sections">

          <li id="title">
              <div class="annotation">
                  <h1>table.redux.js</h1>
              </div>
          </li>



        <li id="section-1">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> Queue = <span class="hljs-built_in">require</span>(<span class="hljs-string">'procession'</span>)

<span class="hljs-keyword">var</span> RBTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bintrees'</span>).RBTree

<span class="hljs-keyword">var</span> Interrupt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'interrupt'</span>).createInterrupter(<span class="hljs-string">'diffuser'</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Table</span> (<span class="hljs-params">redundancy, workers</span>) </span>{
    <span class="hljs-keyword">this</span>.events = <span class="hljs-keyword">new</span> Queue
    <span class="hljs-keyword">this</span>.addresses = []
    <span class="hljs-keyword">this</span>.buckets = []
    <span class="hljs-keyword">this</span>.redundancy = redundancy
    <span class="hljs-keyword">this</span>.workers = workers
    <span class="hljs-keyword">this</span>.balanced = []
}

<span class="hljs-keyword">var</span> RBTree = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bintrees'</span>).RBTree
<span class="hljs-keyword">var</span> Monotonic = <span class="hljs-built_in">require</span>(<span class="hljs-string">'monotonic'</span>).asString

Table.prototype.bootstrap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
}

Table.prototype._balance = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">balance</span> (<span class="hljs-params">buckets, addresses</span>) </span>{
    <span class="hljs-keyword">var</span> counters = {}
    addresses.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">address</span>) </span>{
        counters[address] = <span class="hljs-number">0</span>
    })

    buckets.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promise</span>) </span>{
        counters[promise]++
    })

    <span class="hljs-keyword">var</span> loaded = <span class="hljs-keyword">new</span> RBTree(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">left, right</span>) </span>{
        <span class="hljs-keyword">var</span> compare = left.count - right.count
        <span class="hljs-keyword">if</span> (compare != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> compare
        }
        <span class="hljs-keyword">return</span> Monotonic.compare(left.promise, right.promise)
    })

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> promise <span class="hljs-keyword">in</span> counters) {
        loaded.insert({ <span class="hljs-attr">promise</span>: promise, <span class="hljs-attr">count</span>: counters[promise] })
    }

    <span class="hljs-keyword">var</span> balance = buckets.length % addresses.length == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>

    <span class="hljs-keyword">var</span> min, max
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Math</span>.abs(loaded.min().count - loaded.max().count) &gt; balance) {
        max = loaded.max()
        min = loaded.min()
        loaded.remove(min)
        loaded.remove(max)
        buckets[buckets.indexOf(max.promise)] = min.promise
        max.count--
        min.count++
        loaded.insert(max)
        loaded.insert(min)
    }
}</pre></div></div>

        </li>


        <li id="section-2">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>We can implement our balancing logic assuming that there the instance with the
maximum number of buckets will have zero buckets.</p>

            </div>

        </li>


        <li id="section-3">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>We always want to have more buckets than there are intances. Furthermore, we
want to ensure that there are more buckets than there are total workers, that
is instances by workers per instance. For now weâ€™re going to do instances *
workers * 2 to get our desired buckets.</p>
<p>Our table length is a power of 2 so that we can index it using <code>hash &amp;
(length - 1)</code> and we can double it by appending a copy of the table to
itself. When doing so <code>hash &amp; (length - 1)</code> will return the same value for
the newly doubled table. The new mask will include an additional most
significant bit. All that bit it going to do is determine whehter to look in
the first half or the second half of the table, then the remaining bits
determine the index within the half. Since the second half is a duplicate of
the first half, the value returned is the same.</p>

            </div>

        </li>


        <li id="section-4">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>

            </div>

            <div class="content"><div class='highlight'><pre>
Table.prototype.arrive = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">self, promise</span>) </span>{
    <span class="hljs-keyword">this</span>.addresses.push(promise)
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.addresses.length == <span class="hljs-number">1</span>) {
        Interrupt.assert(promise == self, <span class="hljs-string">'bad.bootstrap.promise'</span>)
        <span class="hljs-keyword">this</span>.buckets.push(promise)
        <span class="hljs-keyword">this</span>.events.push(<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify({
            <span class="hljs-attr">module</span>: <span class="hljs-string">'diffuser'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'balance'</span>,
            <span class="hljs-attr">addresses</span>: <span class="hljs-keyword">this</span>.addresses,
            <span class="hljs-attr">buckets</span>: <span class="hljs-keyword">this</span>.buckets
        })))
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buckets.length &lt; <span class="hljs-keyword">this</span>.redundancy) {</pre></div></div>

        </li>


        <li id="section-5">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Ensure we have plenty of buckets. See discussion of doubling above.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> buckets = <span class="hljs-keyword">this</span>.buckets.slice()
        <span class="hljs-keyword">var</span> minimum = <span class="hljs-keyword">this</span>.addresses.length * <span class="hljs-keyword">this</span>.workers * <span class="hljs-number">2</span>
        <span class="hljs-keyword">while</span> (buckets.length &lt; minimum) {
            buckets.push.apply(buckets, buckets)
        }</pre></div></div>

        </li>


        <li id="section-6">
            <div class="annotation">

              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>TODO Not sure what we need to keep in order to fallback.</p>

            </div>

            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>._balance(buckets, <span class="hljs-keyword">this</span>.addresses)
        <span class="hljs-keyword">this</span>.balanced.push(buckets)
        <span class="hljs-keyword">this</span>.events.push(<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify({
            <span class="hljs-attr">module</span>: <span class="hljs-string">'diffuser'</span>,
            <span class="hljs-attr">method</span>: <span class="hljs-string">'balance'</span>,
            <span class="hljs-attr">promise</span>: promise,
            <span class="hljs-attr">buckets</span>: <span class="hljs-keyword">this</span>.buckets,
            <span class="hljs-attr">balanced</span>: buckets,
            <span class="hljs-attr">addresses</span>: <span class="hljs-keyword">this</span>.addresses
        })))
    }
}

<span class="hljs-built_in">module</span>.exports = Table</pre></div></div>

        </li>

    </ul>
  </div>
</body>
</html>
