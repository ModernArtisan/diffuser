diff -Naur _node_modules/conduit/window.js node_modules/conduit/window.js
--- _node_modules/conduit/window.js	2019-03-30 17:10:42.000000000 -0400
+++ node_modules/conduit/window.js	2019-03-30 17:10:54.000000000 -0400
@@ -16,6 +16,8 @@
 
 var Interrupt = require('interrupt').createInterrupter('conduit/window')
 
+var logger = require('prolific.logger').createLogger('conduit/window')
+
 function Window (destructible, options) {
     this.outbox = new Procession
     this.inbox = new Procession
@@ -45,9 +47,13 @@
     this._socket.destructible.completed.unlatch()
 
     this._connection = 0
+
+    this._id = coalesce(options.id)
+
+    logger.trace('created', { id: this._id })
 }
 
-Window.prototype._connect = cadence(function (async, destructible, inbox, outbox) {
+Window.prototype._connect = cadence(function (async, destructible, inbox, outbox, connection) {
     async(function () {
         // Shutdown our previous connections to a bi-directional pair.
         // TODO Possible race when two or more calls to `_connect` wait for the
@@ -56,22 +62,28 @@
         this._socket.inbox.destroy()
         this._socket.destructible.completed.wait(async())
     }, function () {
+        Interrupt.assert(connection == this._connection, 'suspected race condition', { id: this._id })
         // Read the new input into our `_pull` function.
         var pump = inbox.pump(this, '_receive')
         pump.run(destructible.durable('inbox'))
         var reservoir = this._reservoir
         this._reservoir = outbox.shifter()
-        var entry
-        while ((entry = reservoir.shift()) != null) {
+        var entry = reservoir.shift(), first = entry, last = null
+        logger.trace('connected', { id: this._id, connection: connection })
+        while (entry != null) {
             outbox.push(entry)
+            last = entry
+            entry = reservoir.shift()
         }
+        logger.trace('reservoir', { id: this._id, connection: connection, $first: first, $last: last })
         this._socket.outbox.end()
-        this._socket = { inbox: pump, outbox: outbox, destructible: destructible }
+        this._socket = { inbox: pump, outbox: outbox, destructible: destructible, connection: connection }
     })
 })
 
 Window.prototype.connect = function (inbox, outbox) {
-    this._destructible.ephemeral([ 'connect', this._connection++ ], this, '_connect', inbox, outbox, null)
+    var connection = ++this._connection
+    this._destructible.ephemeral([ 'connect', connection ], this, '_connect', inbox, outbox, connection, null)
 }
 
 // We can shutdown our side of the window by running null through the window's
@@ -135,6 +147,13 @@
             // We might lose an envelope. We're going to count on this being a
             // break where a conduit reconnect causes the messages to be resent
             // but we could probably request a replay ourselves.
+            if (this._received != envelope.previous) {
+                logger.trace('ahead', {
+                    id: this._id,
+                    connection: this._socket.connection,
+                    $envelope: envelope
+                })
+            }
             Interrupt.assert(this._received == envelope.previous, 'ahead')
             // Note the last received sequence.
             this._received = envelope.sequence
@@ -146,16 +165,28 @@
                     sequence: this._received
                 })
                 this._flush = Monotonic.add(this._flush, this._window)
+                logger.trace('flush', {
+                    id: this._id,
+                    connection: this._socket.connection,
+                    sequence: this._received,
+                    flush: this._flush
+                })
             }
             // Forward the body which might actually be `null` end-of-stream.
             this.inbox.enqueue(envelope.body, async())
             break
         case 'flush':
             // Shift the messages that we've received off of the reservoir.
+            logger.trace('flushing', {
+                id: this._id,
+                connection: this._socket.connection,
+                $envelope: envelope
+            })
             for (;;) {
                 var peek = this._reservoir.peek()
                 // TODO `peek` should never be `null`.
-                if (peek == null || peek.sequence == envelope.sequence) {
+                Interrupt.assert(peek != null, 'null peek on flush')
+                if (peek.sequence == envelope.sequence) {
                     break
                 }
                 this._reservoir.shift()
