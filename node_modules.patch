diff -Naur _node_modules/arguable/index.js node_modules/arguable/index.js
--- _node_modules/arguable/index.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/arguable/index.js	2019-03-31 12:00:16.000000000 -0400
@@ -151,7 +151,7 @@
 
         arguable.scram = scram.value
 
-        var destructible = new Destructible(scram, identifier)
+        var destructible = new Destructible(arguable.scram, identifier)
 
         var trap = { SIGINT: 'destroy', SIGTERM: 'destroy', SIGHUP: 'swallow' }
         var $trap = ('$trap' in options) ? options.$trap : {}
@@ -206,6 +206,7 @@
         var exit = new Signal
         var child = new Child(destructible, exit, options)
         destructible.completed.wait(function () {
+            console.log('MAIN IS COMPLETE', destructible.key, arguments)
             var vargs = []
             vargs.push.apply(vargs, arguments)
             if ($untrap) {
@@ -244,6 +245,7 @@
                 return vargs.concat(child)
             })
         }), function () {
+            console.log('MAIN IS DONE', destructible.key, arguments)
             if (arguments[0] == null) {
                 callback.apply(null, arguments)
             } else {
diff -Naur _node_modules/compassion.colleague/local.js node_modules/compassion.colleague/local.js
--- _node_modules/compassion.colleague/local.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/compassion.colleague/local.js	2019-03-31 12:07:33.000000000 -0400
@@ -321,6 +321,7 @@
         this.scheduler.schedule(Date.now() + this._ping.chaperon, envelope.key, envelope.body)
         break
     case 'unrecoverable':
+        console.log('YES DESTROY LOCAL')
         this._destructible.destroy()
         break
     }
diff -Naur _node_modules/compassion.colleague/olio.js node_modules/compassion.colleague/olio.js
--- _node_modules/compassion.colleague/olio.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/compassion.colleague/olio.js	2019-03-31 02:46:55.000000000 -0400
@@ -29,6 +29,7 @@
         var timeout = coalesce(properties.timeout, {})
         var resolver = new Resolver(sender.processes[0].conduit)
         var bind = coalesce(properties.bind, {})
+        destructible.destruct.wait(function () { console.log('YES DESTRUCT') })
         destructible.durable('containerized', Containerized, {
             population: new Population(resolver, ua),
             ping: {
diff -Naur _node_modules/conduit/window.js node_modules/conduit/window.js
--- _node_modules/conduit/window.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/conduit/window.js	2019-03-31 13:30:36.000000000 -0400
@@ -16,6 +16,8 @@
 
 var Interrupt = require('interrupt').createInterrupter('conduit/window')
 
+var logger = require('prolific.logger').createLogger('conduit.window')
+
 function Window (destructible, options) {
     this.outbox = new Procession
     this.inbox = new Procession
@@ -45,9 +47,13 @@
     this._socket.destructible.completed.unlatch()
 
     this._connection = 0
+
+    this._id = coalesce(options.id)
+
+    logger.trace('created', { id: this._id })
 }
 
-Window.prototype._connect = cadence(function (async, destructible, inbox, outbox) {
+Window.prototype._connect = cadence(function (async, destructible, inbox, outbox, connection) {
     async(function () {
         // Shutdown our previous connections to a bi-directional pair.
         // TODO Possible race when two or more calls to `_connect` wait for the
@@ -56,22 +62,27 @@
         this._socket.inbox.destroy()
         this._socket.destructible.completed.wait(async())
     }, function () {
+        Interrupt.assert(connection == this._connection, 'suspected race condition', { id: this._id })
         // Read the new input into our `_pull` function.
         var pump = inbox.pump(this, '_receive')
         pump.run(destructible.durable('inbox'))
         var reservoir = this._reservoir
         this._reservoir = outbox.shifter()
-        var entry
-        while ((entry = reservoir.shift()) != null) {
+        var entry = reservoir.shift(), first = entry, last = null
+        while (entry != null) {
             outbox.push(entry)
+            last = entry
+            entry = reservoir.shift()
         }
+        logger.trace('connecting', { id: this._id, connection: connection, $first: first, $last: last })
         this._socket.outbox.end()
-        this._socket = { inbox: pump, outbox: outbox, destructible: destructible }
+        this._socket = { inbox: pump, outbox: outbox, destructible: destructible, connection: connection }
     })
 })
 
 Window.prototype.connect = function (inbox, outbox) {
-    this._destructible.ephemeral([ 'connect', this._connection++ ], this, '_connect', inbox, outbox, null)
+    var connection = ++this._connection
+    this._destructible.ephemeral([ 'connect', connection ], this, '_connect', inbox, outbox, connection, null)
 }
 
 // We can shutdown our side of the window by running null through the window's
@@ -135,7 +146,18 @@
             // We might lose an envelope. We're going to count on this being a
             // break where a conduit reconnect causes the messages to be resent
             // but we could probably request a replay ourselves.
-            Interrupt.assert(this._received == envelope.previous, 'ahead')
+            if (this._received != envelope.previous) {
+                logger.trace('ahead', {
+                    id: this._id,
+                    received: this._received,
+                    connection: this._socket.connection,
+                    $envelope: envelope
+                })
+            }
+            Interrupt.assert(this._received == envelope.previous, 'ahead', {
+                received: this._received,
+                envelope: envelope
+            })
             // Note the last received sequence.
             this._received = envelope.sequence
             // Send a flush if we've reached the end of a window.
@@ -146,16 +168,28 @@
                     sequence: this._received
                 })
                 this._flush = Monotonic.add(this._flush, this._window)
+                logger.trace('flush', {
+                    id: this._id,
+                    connection: this._socket.connection,
+                    sequence: this._received,
+                    flush: this._flush
+                })
             }
             // Forward the body which might actually be `null` end-of-stream.
             this.inbox.enqueue(envelope.body, async())
             break
         case 'flush':
             // Shift the messages that we've received off of the reservoir.
+            logger.trace('flushing', {
+                id: this._id,
+                connection: this._socket.connection,
+                $envelope: envelope
+            })
             for (;;) {
                 var peek = this._reservoir.peek()
                 // TODO `peek` should never be `null`.
-                if (peek == null || peek.sequence == envelope.sequence) {
+                Interrupt.assert(peek != null, 'null peek on flush')
+                if (peek.sequence == envelope.sequence) {
                     break
                 }
                 this._reservoir.shift()
diff -Naur _node_modules/destructible/destructible.js node_modules/destructible/destructible.js
--- _node_modules/destructible/destructible.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/destructible/destructible.js	2019-03-31 12:00:16.000000000 -0400
@@ -61,6 +61,7 @@
 
 Destructible.prototype._return = function () {
     if (this.waiting.length !== 0) {
+        console.log('YES SCRAM', this.key)
         this.completed.unlatch(new Interrupt('scrammed', {
             causes: this._errors,
             destructible: this.key,
@@ -112,10 +113,12 @@
             // shutting down in isolation.
             var timer = null
             if (this._runScramTimer) {
+                console.log('SET SCRAM TIMER', this.key)
                 timer = setTimeout(this.scrammed.unlatch.bind(this.scrammed), this._timeout)
             }
             this._completed.wait(this, function () {
                 if (timer != null) {
+                    console.log('CLEAR SCRAM TIMER', this.key)
                     clearTimeout(timer)
                 }
                 this._return()
diff -Naur _node_modules/olio/constituent.js node_modules/olio/constituent.js
--- _node_modules/olio/constituent.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/olio/constituent.js	2019-03-31 13:16:53.000000000 -0400
@@ -49,9 +49,12 @@
             descendent.removeListener('olio:operate', fromParent)
             descendent.removeListener('olio:message', fromSibling)
         })
-        arguable.options.disconnected.once('disconnect', function () {
+        descendent.on('olio:shutdown', function () {
             destructible.destroy()
         })
+        destructible.destruct.wait(function () {
+            arguable.options.disconnected.disconnect()
+        })
 
         descendent.across('olio:mock', {})
         descendent.up(+coalesce(process.env.OLIO_SUPERVISOR_PROCESS_ID, 0), 'olio:registered', {})
@@ -59,6 +62,9 @@
         async(function () {
             dispatcher.olio.wait(async())
         }, function (olio, source, properties) {
+            destructible.destruct.wait(function () {
+                console.log('CONSTITUENT DESTRUCT', source)
+            })
             var Child = Resolve(source, require)
             async(function () {
                 require('prolific.sink').properties.olio = { name: olio.name, index: olio.index }
diff -Naur _node_modules/olio/listener.js node_modules/olio/listener.js
--- _node_modules/olio/listener.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/olio/listener.js	2019-03-31 13:15:31.000000000 -0400
@@ -109,7 +109,10 @@
         var pids = []
         for (var i = 0; i < workers; i++) {
             var worker = cluster.fork({ OLIO_WORKER_INDEX: i })
-            this._destructible.destruct.wait(worker, function () { this.disconnect() })
+            this._destructible.destruct.wait({ pid: worker.pid, name: name }, function () {
+                console.log('DISCONNECTING A', this.name)
+                descendent.down([ this.pid ], 'olio:disconnect', true)
+            })
             descendent.addChild(worker.process, {
                 program: { name: 'program', index: 0 },
                 process: { name: name, index: i }
diff -Naur _node_modules/olio/monitor.js node_modules/olio/monitor.js
--- _node_modules/olio/monitor.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/olio/monitor.js	2019-03-31 13:24:36.000000000 -0400
@@ -1,10 +1,11 @@
 var delta = require('delta')
 var cadence = require('cadence')
+var logger = require('prolific.logger').createLogger('olio')
 
 module.exports = cadence(function (async, Interrupt, self, child) {
     async(function () {
         delta(async()).ee(child).on('exit')
     }, function (code, signal) {
-        Interrupt.assert(self.destroyed || signal == 'SIGINT', 'olio.exit', { code: code, signal: signal })
+        logger.notice('exit', { code: code, signal: signal })
     })
 })
diff -Naur _node_modules/prolific.shuttle/shuttle.js node_modules/prolific.shuttle/shuttle.js
--- _node_modules/prolific.shuttle/shuttle.js	2019-03-31 02:22:39.000000000 -0400
+++ node_modules/prolific.shuttle/shuttle.js	2019-03-31 03:03:18.000000000 -0400
@@ -49,6 +49,7 @@
         descendent.process.on('uncaughtException', function (error) {
             uncaughtException(error)
             queue.exit()
+            throw error
         })
     }
 
